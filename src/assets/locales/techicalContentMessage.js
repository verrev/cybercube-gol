export default `<h1 id="dependancies">Dependancies</h1> <h3 id="general-considerations">General considerations</h3> <p>This project is written in ES6 and it uses the React framework. The dependancies are separated into the ones needed during development (devDependancies in package.json) and the packages that get embedded into the final bundle (dependancies in package.json). I generally prefer to keep the amount of external dependancies that end up in the final bundle as small as possible so as to simplify keeping the app up-to-date. Before every commit two automated processes take place: 1. eslint goes over all the staged files and validates that there are no syntactic errors found. If there are, the commit will be aborted so it is not possible to commit code with syntactic errors. 2. prettier goes over the staged files and formats the code in a consistent manner.</p> <h3 id="development-dependancies">Development dependancies</h3> <p><em>Note: the @ symbol preceeding some packages denotes that the library is namespaced under some organization</em></p> <ul> <li><strong>@babel/core</strong> â€” employed to allow me to use ES6 language features and have it transpiled to JavaScript current browsers can execute</li> <li><strong>@babel/plugin-proposal-class-properties</strong> â€” added to use a static class field from an upcoming standard</li> <li><strong>@babel/preset-env</strong> â€” Babel works using plugins, each plugin does one transformation. For example, there is a package for transforming ES6 arrow functions. Preset-env configures and pulls in all transformations for all the ES6 new features saving us the legwork of adding everything separately</li> <li><strong>@babel/preset-react</strong> â€” Pulls in transformations required by using JSX</li> <li><strong>babel-eslint</strong> â€” by default, eslint can only validate the latest implemented ES standard, meaning ES6 would not get processed correctly. This package will rectify this problem</li> <li><strong>babel-loader</strong> â€” The â€˜glueâ€™ between webpack and babel. This webpack loader will process each module using babel when itâ€™s time to create a bundle</li> <li><strong>css-loader</strong> â€” This allows css files to be â€œincludedâ€ into .js files</li> <li><strong>eslint</strong> â€” This validates the .js files for syntactic errors</li> <li><strong>eslint-plugin-react</strong> â€” By default, eslint can only validate â€˜normalâ€™ ES. This package adds the power of checking react-specific code to eslint</li> <li><strong>html-webpack-plugin</strong> â€” Simplifies thecreation of HTML files to serve created webpack bundles</li> <li><strong>husky</strong> â€” Allows to configure processes that should take place during a git action. I use it in the project to automatically lint and prettify committed files and abort the commit if eslint fails.</li> <li><strong>lint-staged</strong> â€” Gathers the list of staged files and runs linters on them</li> <li><strong>node-sass</strong> â€” Allows the SASS compiler written in C to be executed from a node environment</li> <li><strong>sass-loader</strong> â€”Transforms .sass or .scss files to normal .css files</li> <li><strong>style-loader</strong> â€” The webpack loader that makes importing .css files possible</li> <li><strong>svg-url-loader</strong> â€” A webpack loader that will allow importing .svg files, I use it from a .sass file which in turn gets included into the final bundle</li> <li><strong>webpack</strong> â€” A popular tool that allows modules to be in separate files, but combines them into a single .js file ready for hosting</li> <li><strong>webpack-cli</strong> â€” Webpack CLI provides a flexible set of commands for developers which get called as webpack is making a bundle</li> <li><strong>webpack-dev-server</strong> â€” A very handy tool to be used locally while developing the app. Automatically hosts the bundle and supports reloading upon detecting changes in the code</li> <li><strong>eslint-plugin-jest</strong> â€” Configures eslint for validating Jest test files</li> <li><strong>jest</strong> â€” A testing framework by React, runs the tests under the tests directory</li> <li><strong>jest-puppeteer</strong> â€” Allows to write Jest tests that get executed and sent to a chromium instance</li> <li><strong>puppeteer</strong> â€” A package that provides an API to interact with a browser</li> </ul> <h3 id="shipped-dependancies">Shipped dependancies</h3> <ul> <li><strong>classnames</strong> â€” A small library which allows to clean up HTML class declarations based on conditional logic.</li> <li><strong>prop-types</strong> â€” Allows defining the type of value for props. Will give a warning in the console during development if a propâ€™s type doesnâ€™t match itâ€™s expected type or itâ€™s missing altogether</li> <li><strong>react</strong> â€” The best JavaScript framework on the market ğŸ˜Š</li> <li><strong>react-dom</strong> â€” Provides functions which will allow a React app to be rendered in the browser</li> <li><strong>react-intl</strong> â€” One of the most mature libraries for internationalizing apps</li> <li><strong>react-router-dom</strong> â€” Allows creating seperate URLs for a single-page-application</li> </ul> <h1 id="file-structure">File structure</h1> <p>The project is structured as follows:</p> <p>â”œâ”€â”€ <strong>dist</strong> <br> â”œâ”€â”€ <strong>node_modules</strong> <br> â”œâ”€â”€ Dockerfile <br> â”œâ”€â”€ README.md <br> â”œâ”€â”€ jest-puppeteer.config.js <br> â”œâ”€â”€ jest.config.json <br> â”œâ”€â”€ package.json <br> â”œâ”€â”€ <strong>src</strong> <br> â”‚ â”œâ”€â”€ App.js <br> â”‚ â”œâ”€â”€ <strong>assets</strong> <br> â”‚ â”‚ â”œâ”€â”€ <strong>images</strong> <br> â”‚ â”‚ â”‚ â”œâ”€â”€ ee.svg <br> â”‚ â”‚ â”‚ â”œâ”€â”€ favicon.ico <br> â”‚ â”‚ â”‚ â”œâ”€â”€ ru.svg <br> â”‚ â”‚ â”‚ â””â”€â”€ us.svg <br> â”‚ â”‚ â”œâ”€â”€ index.html <br> â”‚ â”‚ â”œâ”€â”€ index.sass <br> â”‚ â”‚ â”œâ”€â”€ locales <br> â”‚ â”‚ â”‚ â”œâ”€â”€ messages.js <br> â”‚ â”‚ â”‚ â””â”€â”€ techicalContentMessage.js <br> â”‚ â”‚ â”œâ”€â”€ <strong>styles</strong> <br> â”‚ â”‚ â”‚ â””â”€â”€ <strong>blocks</strong> <br> â”‚ â”‚ â”‚ â”œâ”€â”€ canvas.sass <br> â”‚ â”‚ â”‚ â”œâ”€â”€ menu.sass <br> â”‚ â”‚ â”‚ â”œâ”€â”€ override-slider.sass <br> â”‚ â”‚ â”‚ â”œâ”€â”€ settings.sass <br> â”‚ â”‚ â”‚ â””â”€â”€ text-wrapper.sass <br> â”‚ â”‚ â””â”€â”€ var.sass <br> â”‚ â”œâ”€â”€ <strong>components</strong> <br> â”‚ â”‚ â”œâ”€â”€ <strong>Canvas</strong> <br> â”‚ â”‚ â”‚ â””â”€â”€ index.js <br> â”‚ â”‚ â”œâ”€â”€ <strong>Menu</strong> <br> â”‚ â”‚ â”‚ â””â”€â”€ index.js <br> â”‚ â”‚ â”œâ”€â”€ <strong>Settings</strong> <br> â”‚ â”‚ â”‚ â””â”€â”€ index.js <br> â”‚ â”‚ â””â”€â”€ <strong>TextWrapper</strong> <br> â”‚ â”‚ â””â”€â”€ index.js <br> â”‚ â”œâ”€â”€ <strong>containers</strong> <br> â”‚ â”‚ â”œâ”€â”€ CanvasContainer.js <br> â”‚ â”‚ â”œâ”€â”€ GameOfLifeContainer.js <br> â”‚ â”‚ â”œâ”€â”€ MenuContainer.js <br> â”‚ â”‚ â”œâ”€â”€ SettingsContainer.js <br> â”‚ â”‚ â””â”€â”€ TextPageContainer.js <br> â”‚ â”œâ”€â”€ index.js <br> â”‚ â””â”€â”€ <strong>utils</strong> <br> â”‚ â””â”€â”€ gameOfLifeHelpers.js <br> â”œâ”€â”€ <strong>tests</strong> <br> â”‚ â”œâ”€â”€ <strong>e2e</strong> <br> â”‚ â”‚ â””â”€â”€ index.test.js <br> â”‚ â”œâ”€â”€ <strong>screenshots</strong> <br> â”‚ â”‚ â””â”€â”€ homepage_and_canvas.jpg <br> â”‚ â””â”€â”€ <strong>unit</strong> <br> â”‚ â””â”€â”€ gameOfLifeHelpersTests <br> â”‚ â”œâ”€â”€ addLivingCells.test.js <br> â”‚ â”œâ”€â”€ initializeGameState.test.js <br> â”‚ â””â”€â”€ updateGameState.test.js <br> â”œâ”€â”€ webpack.config.js <br> â””â”€â”€ yarn.lock</p> <p>At the project root, there are:</p> <ol> <li><strong>.babelrc, .eslintrc, .prettierrc</strong> which configure each respective devtool for the project</li> <li><strong>.gitignore</strong>, which avoids polluting git with unneeded output bundles and installed sources for node_modules</li> <li><strong>package.json</strong>, which configures</li> <li><strong>webpack.config.js</strong>, which configures webpack with the necessary loaders and plugins</li> <li><strong>yarn.lock</strong>, which keeps track of the versions for each installed node module, this does the same work as package-lock.json/shrinkwrap but since I prefer using the faster yarn, itâ€™s called yarn.lock</li> <li><strong>src</strong> folder, this contains the actual project files that get bundled to a single js file by webpack and this gets served to a client</li> <li><strong>node_modules</strong>, is not committed to the repository, but built locally upon running yarn, contains the dependancies for the app</li> <li><strong>dist</strong>, is not committed to the repository, but when running yarn build it will contain the static files that can be hosted on a webserver</li> <li><strong>tests</strong>, contains the end-to-end as well as unit tests for Jest</li> <li><strong>.dockerignore</strong>, contains the directories that should not be copied into the first docker image/build step</li> <li><strong>Dockerfile</strong>, used for configuring a docker image</li> <li><strong>jest-puppeteer.config.js</strong>, configures the bridge between Jest and Puppeteer</li> <li><strong>jest.config.json</strong>, configures the Jest testing framework</li> <li><strong>README.md</strong>, standard name for a technical document detailing how to work with the source</li> </ol> <p>Taking the <strong>src</strong> directory as a starting point, we have four folders and two files:</p> <ol> <li><strong>assets</strong>, which contains all the static assets like images, translations, icons and style files. It also contains the index.html file which is used by webpack as a starting point into which the final bundle is included</li> <li><strong>components</strong>, which houses all the presentational React pure components that have no side effect and are designed to be wrapped in containers which deal with providing the correct data to the components</li> <li><strong>containers</strong>, which holds all the â€œsmartâ€ React components that deal with event listeners, states, and contains â€œbusinessâ€ logic for making the game work</li> <li><strong>utils</strong>, which holds a file with helper functions that are used for initializing, transforming and drawing the game state to the canvas. This is done to keep the CanvasContainer more manageable in size</li> <li><strong>App.js</strong> - the â€œentrypointâ€ to the application, defines the available routes and adds a menu to the app for all routes. Also configures react-intl to provide all the components access to translations</li> <li><strong>index.js</strong> - this is the root file for webpack. Itâ€™s where the bundling process will begin and where React-dom is invoked to render the entire app into a div defined in the index.html from the <strong>assets</strong> directory</li> </ol> <h1 id="architecture-considerations">Architecture considerations</h1> <p>The project has a simple, but hopefully clear structure. The <strong>App.js</strong> starting point will define available pages where each page is a container. Containers do not render HTML tags as this work is offloaded to components. These are pure functions with no side-effects and due to this choice, the presentational layer is clearly separated from the business logic driving the app. In this way, itâ€™s easier to make changes in the future and itâ€™s also considered a best practice by many. Generally, containers will return a component that renders a part of the app based on the props it receives from the parent. It is also possible for a container to return another container if need be, as is done with <strong>GameOfLifeContainer.js</strong>, which returns two containers and links them together (one is for setting the FPS and the other will do the rendering onto the canvas).</p> <p>For styling the app, SASS is used with the .sass syntax (there is also .scss, which retains curly braces and adds features like easy syntax variables and mixins, but I quite like the reduced syntax of .sass files. No IDâ€™s are used except for rendering the app to the root div. To introduce clarity and unity into the naming of classes, a methodology called <strong>BEM</strong> (block, element, modifier) is used. This works especially well with .sass because it allows for nesting elements and modifiers to blocks using whitespaces. All the style files are placed under the blocks subdirectory in <strong>src/assets/styles</strong> and each file defines one BEM block. The file name will generally match the name of the block class. There is a root style file called <strong>index.sass</strong> which sets some defaults that are common for all components of the project. Normalize is pulled in so as to introduce consistency between browsers and some basic attributes such as sizes and the font family for headers and html/body are defined. Common variables are created in <strong>var.sass</strong> and this file is imported in all the block files. If a variable would have to change, the update will only need to be done in one central file.</p> <p>No hardcoded strings are used in JSX. I generally do this even if I only support one language, because itâ€™s vastly easier to implement translations from the get-go instead of trying to refactor the support in later as the requirements add a new language. React-intl is used to handle translations and it also provides definitions for correct locale-based number and date formats as well, although these are not utilized in this project.</p> <p>I also employ absolute paths for all imports. This is done to improve the readability of paths as well as help in finding where a file is used by searching where each file is imported. The imports are ordered with the npm packages coming first, local files after those and style files last. Its also a noteworthy advantage, that when a file is moved to a different directory during refactoring, the imports in the moved file can stay as they are.</p> <p>In general, I try to keep as much consistency between similar concepts as possible so if there would be another developer joining (or even if I picked up the project months or years later) there are less concepts they would have to learn and memorize.</p> <h1 id="testing">Testing</h1> <p>To ensure the high quality of an application, testing the software on different levels helps reduce bugs considerably. In this project, I have covered three layers of testing: <br> 1. <strong>Static tests</strong> â€” Here I use eslint to block off all commits into the codebase that contain mistakes that are statically analyzable. <br> 2. <strong>Unit tests</strong> â€” Here I use a popular JavaScript testing framework built by Facebook with the aim of testing React apps (but really can be used to test other kinds of web apps as well!) called Jest. It has a simple, concise syntax for tests and requires very little configuration out of the box. I use it to test the helper functions that make the Game of Life simulation work <br> 3. <strong>End-to-end tests</strong> â€” This phase of testing is running the application and simulating a real end user, by visiting pages, clicking on links and buttons and asserting certain known qualities about the various parts of the app. This type of testing allows to go through entire flows in more complex applications and validating the adherence of the front end implementation to the business rules. In my case, I visit all pages and assert that there are parts of known text displayed on each page. I also â€˜clickâ€™ on the canvas and take a screenshot so a tester has visual feedback. This is especially useful, when new features are added and a developer can quickly ensure by looking at the screenshots that other parts of a big app havenâ€™t broken due to the changes they have made, all without having to check the other parts manually at all. I use Jest as the testing framework and connect that to Puppeteer which is a tool for running a browser (usually headless but I have configured it to show the browser in package.json). This way, one can see the actions being undertaken as the app runs.</p> <h1 id="deploying">Deploying</h1> <p>When all is said and done, it comes time to deploy the application. This can either be done by executing</p> <p><strong>yarn build</strong></p>and copying the contents of the <strong>./dist</strong> folder to a server that supports serving static files. To give an alternative to this and to make the process slightly easier and more automated, I have added a <strong>Dockerfile</strong> which can be used to build and run a container that will automatically be populated with the app built in production mode. <br> To deploy using Docker, I have used a nice feature called multi-stage builds. Here, we pull in a node container that we use to build the application using webpack and take the result out of that container, copying into the next container which is a simple autoconfigurated nginx instance. That will do the actual serving at port 80. To do all this, simply run while in the project root directory</p> <p><strong>docker build -t best-gol-implementation .</strong></p> <p><strong>docker run -p 80:80 best-gol-implementation</strong></p><p>and enjoy the best Game of Life implementation at <a href="http://localhost">http://localhost</a>.</p> <h1 id="final-thoughts">Final thoughts</h1> <p>This project was an interesting one for me, since I havenâ€™t done much work with the canvas. Perhaps the most work came from getting the layout correct for smaller screens and having the canvas resize to the correct dimensions. I hope that what I have done here resonates with you and will not leave you confused. Iâ€™d like to thank You for this challenge and wish you the best!</p>`;
