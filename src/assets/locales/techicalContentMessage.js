export default '<h1 id="dependancies">Dependancies</h1>\r\n<h3 id="general-considerations">General considerations</h3>\r\n<p>This project is written in ES6 and it uses the React framework. The dependancies are separated into the ones needed during development (devDependancies in package.json) and the packages that get embedded into the final bundle (dependancies in package.json). I generally prefer to keep the amount of external dependancies that end up in the final bundle as small as possible so as to simplify keeping the app up-to-date. Before every commit two automated processes take place: 1. eslint goes over all the staged files and validates that there are no syntactic errors found. If there are, the commit will be aborted so it is not possible to commit code with syntactic errors. 2. prettier goes over the staged files and formats the code in a consistent manner.</p>\r\n<h3 id="development-dependancies">Development dependancies</h3>\r\n<p><em>Note: the @ symbol preceeding some packages denotes that the library is namespaced under some organization</em></p>\r\n<ul>\r\n<li><strong>@babel/core</strong> \u2014 employed to allow me to use ES6 language features and have it transpiled to JavaScript current browsers can execute</li>\r\n<li><strong>@babel/plugin-proposal-class-properties</strong> \u2014 added to use a static class field from an upcoming standard</li>\r\n<li><strong>@babel/preset-env</strong> \u2014 Babel works using plugins, each plugin does one transformation. For example, there is a package for transforming ES6 arrow functions. Preset-env configures and pulls in all transformations for all the ES6 new features saving us the legwork of adding everything separately</li>\r\n<li><strong>@babel/preset-react</strong> \u2014 Pulls in transformations required by using JSX</li>\r\n<li><strong>babel-eslint</strong> \u2014 by default, eslint can only validate the latest implemented ES standard, meaning ES6 would not get processed correctly. This package will rectify this problem</li>\r\n<li><strong>babel-loader</strong> \u2014 The \u2018glue\u2019 between webpack and babel. This webpack loader will process each module using babel when it\u2019s time to create a bundle</li>\r\n<li><strong>css-loader</strong> \u2014 This allows css files to be \u201Cincluded\u201D into .js files</li>\r\n<li><strong>eslint</strong> \u2014 This validates the .js files for syntactic errors</li>\r\n<li><strong>eslint-plugin-react</strong> \u2014 By default, eslint can only validate \u2018normal\u2019 ES. This package adds the power of checking react-specific code to eslint</li>\r\n<li><strong>html-webpack-plugin</strong> \u2014 Simplifies thecreation of HTML files to serve created webpack bundles</li>\r\n<li><strong>husky</strong> \u2014 Allows to configure processes that should take place during a git action. I use it in the project to automatically lint and prettify committed files and abort the commit if eslint fails.</li>\r\n<li><strong>lint-staged</strong> \u2014 Gathers the list of staged files and runs linters on them</li>\r\n<li><strong>node-sass</strong> \u2014 Allows the SASS compiler written in C to be executed from a node environment</li>\r\n<li><strong>sass-loader</strong> \u2014Transforms .sass or .scss files to normal .css files</li>\r\n<li><strong>style-loader</strong> \u2014 The webpack loader that makes importing .css files possible</li>\r\n<li><strong>svg-url-loader</strong> \u2014 A webpack loader that will allow importing .svg files, I use it from a .sass file which in turn gets included into the final bundle</li>\r\n<li><strong>webpack</strong> \u2014 A popular tool that allows modules to be in separate files, but combines them into a single .js file ready for hosting</li>\r\n<li><strong>webpack-cli</strong> \u2014 Webpack CLI provides a flexible set of commands for developers which get called as webpack is making a bundle</li>\r\n<li><strong>webpack-dev-server</strong> \u2014 A very handy tool to be used locally while developing the app. Automatically hosts the bundle and supports reloading upon detecting changes in the code</li>\r\n</ul>\r\n<h3 id="shipped-dependancies">Shipped dependancies</h3>\r\n<ul>\r\n<li><strong>classnames</strong> \u2014 A small library which allows to clean up HTML class declarations based on conditional logic.</li>\r\n<li><strong>prop-types</strong> \u2014 Allows defining the type of value for props. Will give a warning in the console during development if a prop\u2019s type doesn\u2019t match it\u2019s expected type or it\u2019s missing altogether</li>\r\n<li><strong>react</strong> \u2014 The best JavaScript framework on the market \uD83D\uDE0A</li>\r\n<li><strong>react-dom</strong> \u2014 Provides functions which will allow a React app to be rendered in the browser</li>\r\n<li><strong>react-intl</strong> \u2014 One of the most mature libraries for internationalizing apps</li>\r\n<li><strong>react-router-dom</strong> \u2014 Allows creating seperate URLs for a single-page-application</li>\r\n</ul>\r\n<h1 id="file-structure">File structure</h1>\r\n<p>The project is structured as follows:<br>\r\n\u251C\u2500\u2500 <strong>node_modules</strong><br>\r\n\u251C\u2500\u2500 <strong>dist</strong><br>\r\n\u251C\u2500\u2500 package.json<br>\r\n\u251C\u2500\u2500 <strong>src</strong><br>\r\n\u2502 \u251C\u2500\u2500 App.js<br>\r\n\u2502 \u251C\u2500\u2500 <strong>assets</strong><br>\r\n\u2502 \u2502 \u251C\u2500\u2500 <strong>images</strong><br>\r\n\u2502 \u2502 \u2502 \u251C\u2500\u2500 ee.svg<br>\r\n\u2502 \u2502 \u2502 \u251C\u2500\u2500 favicon.ico<br>\r\n\u2502 \u2502 \u2502 \u251C\u2500\u2500 ru.svg<br>\r\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 us.svg<br>\r\n\u2502 \u2502 \u251C\u2500\u2500 index.html<br>\r\n\u2502 \u2502 \u251C\u2500\u2500 index.sass<br>\r\n\u2502 \u2502 \u251C\u2500\u2500 <strong>locales</strong><br>\r\n\u2502 \u2502 \u2502 \u251C\u2500\u2500 messages.js<br>\r\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 techicalContentMessage.js<br>\r\n\u2502 \u2502 \u251C\u2500\u2500 <strong>styles</strong><br>\r\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 <strong>blocks</strong><br>\r\n\u2502 \u2502 \u2502 \u251C\u2500\u2500 canvas.sass<br>\r\n\u2502 \u2502 \u2502 \u251C\u2500\u2500 menu.sass<br>\r\n\u2502 \u2502 \u2502 \u251C\u2500\u2500 override-slider.sass<br>\r\n\u2502 \u2502 \u2502 \u251C\u2500\u2500 settings.sass<br>\r\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 text-wrapper.sass<br>\r\n\u2502 \u2502 \u2514\u2500\u2500 var.sass<br>\r\n\u2502 \u251C\u2500\u2500 <strong>components</strong><br>\r\n\u2502 \u2502 \u251C\u2500\u2500 Canvas<br>\r\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 index.js<br>\r\n\u2502 \u2502 \u251C\u2500\u2500 Menu<br>\r\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 index.js<br>\r\n\u2502 \u2502 \u251C\u2500\u2500 Settings<br>\r\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 index.js<br>\r\n\u2502 \u2502 \u2514\u2500\u2500 TextWrapper<br>\r\n\u2502 \u2502 \u2514\u2500\u2500 index.js<br>\r\n\u2502 \u251C\u2500\u2500 <strong>containers</strong><br>\r\n\u2502 \u2502 \u251C\u2500\u2500 CanvasContainer.js<br>\r\n\u2502 \u2502 \u251C\u2500\u2500 GameOfLifeContainer.js<br>\r\n\u2502 \u2502 \u251C\u2500\u2500 MenuContainer.js<br>\r\n\u2502 \u2502 \u251C\u2500\u2500 SettingsContainer.js<br>\r\n\u2502 \u2502 \u2514\u2500\u2500 TextPageContainer.js<br>\r\n\u2502 \u251C\u2500\u2500 index.js<br>\r\n\u2502 \u2514\u2500\u2500 <strong>utils</strong><br>\r\n\u2502 \u2514\u2500\u2500 gameOfLifeHelpers.js<br>\r\n\u251C\u2500\u2500 webpack.config.js<br>\r\n\u2514\u2500\u2500 yarn.lock</p>\r\n<p>At the project root, there are:</p>\r\n<ol>\r\n<li><strong>.babelrc, .eslintrc, .prettierrc</strong> which configure each respective devtool for the project</li>\r\n<li><strong>.gitignore</strong>, which avoids polluting git with unneeded output bundles and installed sources for node_modules</li>\r\n<li><strong>package.json</strong>, which configures</li>\r\n<li><strong>webpack.config.js</strong>, which configures webpack with the necessary loaders and plugins</li>\r\n<li><strong>yarn.lock</strong>, which keeps track of the versions for each installed node module, this does the same work as package-lock.json/shrinkwrap but since I prefer using the faster yarn, it\u2019s called yarn.lock</li>\r\n<li><strong>src</strong> folder, this contains the actual project files that get bundled to a single js file by webpack and this gets served to a client</li>\r\n<li><strong>node_modules</strong>, is not committed to the repository, but built locally upon running yarn, contains the dependancies for the app</li>\r\n<li><strong>dist</strong>, is not committed to the repository, but when running yarn build it will contain the static files that can be hosted on a webserver</li>\r\n</ol>\r\n<p>Taking the <strong>src</strong> directory as a starting point, we have four folders and two files:</p>\r\n<ol>\r\n<li><strong>assets</strong>, which contains all the static assets like images, translations, icons and style files. It also contains the index.html file which is used by webpack as a starting point into which the final bundle is included</li>\r\n<li><strong>components</strong>, which houses all the presentational React pure components that have no side effect and are designed to be wrapped in containers which deal with providing the correct data to the components</li>\r\n<li><strong>containers</strong>, which holds all the \u201Csmart\u201D React components that deal with event listeners, states, and contains \u201Cbusiness\u201D logic for making the game work</li>\r\n<li><strong>utils</strong>, which holds a file with helper functions that are used for initializing, transforming and drawing the game state to the canvas. This is done to keep the CanvasContainer more manageable in size</li>\r\n<li><strong>App.js</strong> - the \u201Centrypoint\u201D to the application, defines the available routes and adds a menu to the app for all routes. Also configures react-intl to provide all the components access to translations</li>\r\n<li><strong>index.js</strong> - this is the root file for webpack. It\u2019s where the bundling process will begin and where React-dom is invoked to render the entire app into a div defined in the index.html from the <strong>assets</strong> directory</li>\r\n</ol>\r\n<h1 id="architecture-considerations">Architecture considerations</h1>\r\n<p>The project has a simple, but hopefully clear structure. The <strong>App.js</strong> starting point will define available pages where each page is a container. Containers do not render HTML tags as this work is offloaded to components. These are pure functions with no side-effects and due to this choice, the presentational layer is clearly separated from the business logic driving the app. In this way, it\u2019s easier to make changes in the future and it\u2019s also considered a best practice by many. Generally, containers will return a component that renders a part of the app based on the props it receives from the parent. It is also possible for a container to return another container if need be, as is done with <strong>GameOfLifeContainer.js</strong>, which returns two containers and links them together (one is for setting the FPS and the other will do the rendering onto the canvas).</p>\r\n<p>For styling the app, SASS is used with the .sass syntax (there is also .scss, which retains curly braces and adds features like easy syntax variables and mixins, but I quite like the reduced syntax of .sass files. No ID\u2019s are used except for rendering the app to the root div. To introduce clarity and unity into the naming of classes, a methodology called <strong>BEM</strong> (block, element, modifier) is used. This works especially well with .sass because it allows for nesting elements and modifiers to blocks using whitespaces. All the style files are placed under the blocks subdirectory in <strong>src/assets/styles</strong> and each file defines one BEM block. The file name will generally match the name of the block class. There is a root style file called <strong>index.sass</strong> which sets some defaults that are common for all components of the project. Normalize is pulled in so as to introduce consistency between browsers and some basic attributes such as sizes and the font family for headers and html/body are defined. Common variables are created in <strong>var.sass</strong> and this file is imported in all the block files. If a variable would have to change, the update will only need to be done in one central file.</p>\r\n<p>No hardcoded strings are used in JSX. I generally do this even if I only support one language, because it\u2019s vastly easier to implement translations from the get-go instead of trying to refactor the support in later as the requirements add a new language. React-intl is used to handle translations and it also provides definitions for correct locale-based number and date formats as well, although these are not utilized in this project.</p>\r\n<p>I also employ absolute paths for all imports. This is done to improve the readability of paths as well as help in finding where a file is used by searching where each file is imported. The imports are ordered with the npm packages coming first, local files after those and style files last. Its also a noteworthy advantage, that when a file is moved to a different directory during refactoring, the imports in the moved file can stay as they are.</p>\r\n<p>In general, I try to keep as much consistency between similar concepts as possible so if there would be another developer joining (or even if I picked up the project months or years later) there are less concepts they would have to learn and memorize.</p>\r\n<h1 id="final-thoughts">Final thoughts</h1>\r\n<p>This project was an interesting one for me, since I haven\u2019t done much work with the canvas. Perhaps the most work came from getting the layout correct for smaller screens and having the canvas resize to the correct dimensions. I hope that what I have done here resonates with you and will not leave you confused. I\u2019d like to thank You for this challenge and wish you the best!</p>\r\n\r\n';
